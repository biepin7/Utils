[TOC]

## 排序

### 快排
#### 思想 -- 分治
1. 确定分界点 q[l] q[(l+r)/2] q[r] 随机
2. 调整区间: 分为两个区间，左区间内的值 需要 <= x,右区间需要 >= x 
3. 递归处理左右两个区间

对 2. 使用暴力法
- 1. a[] b[] 
- 2. 扫描q[l--r] q[i] <= x ? x->a :x->b
- 3. a->q[] b->q[] 

对 2. 的优美做法 双指针法 

**快速排序**
```
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

**快速选择**
```
int quick_sort(int l, int r, int k) {
    if (l == r) return q[l];

    int x = q[l], i = l - 1, j = r + 1;
    while (i < j) {
        while (q[++i] < x);
        while (q[--j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    int s1 = j - l + 1;
    if (k <= s1) quick_sort(l, j, k);
    else quick_sort(j + 1, r, k - s1);
}
```


### 归并排序

## 二分

### 整数二分

### 浮点数二分
